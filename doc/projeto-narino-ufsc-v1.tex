\documentclass[12pt]{article}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{subfigure}
\usepackage{tikz}
%\renewcommand{\theequation}{\thechapter.\arabic{equation}}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{epsfig}
\usepackage{url}
\usepackage{enumitem}
\usepackage{hyphenat}
\usepackage{textcomp}
\usepackage{gensymb}
\usepackage{tikz,pgf}
\usetikzlibrary{arrows}
%\usepackage{slashbox}
\usepackage{pict2e}
\usepackage{wrapfig}
%\usepackage{txfonts}
%\usepackage{pxfonts}
\linespread{1.2} % Line spacing
\textwidth=16.5cm
\textheight=22.5 cm
\topmargin=-.9cm
\evensidemargin=0cm
\oddsidemargin=0cm
\baselineskip=1.5cm
\parskip=0.5pc
\parsep=.7cm

\newcounter{constrcount}
\setcounter{constrcount}{1}
\newcommand{\DOC}{\texttt{[doc\arabic{constrcount}]}\addtocounter{constrcount}{1}}
\newcommand{\bs}{\begin{center}}
\newcommand{\es}{\end{center}}

\newcounter{gambi}
\setcounter{gambi}{1}
\newcommand{\meuCont}{(\arabic{gambi})\addtocounter{gambi}{1}}

\begin{document}

\vspace*{2cm}
\begin{center}
{\large {\bf Resolução numérica de Equações Diferenciais usando malhas adaptativas}} \\

\vspace{5cm}

\end{center}
\thispagestyle{empty}

%\newpage

\tableofcontents
\thispagestyle{empty}
%\newpage
\pagenumbering{arabic}\setcounter{page}{1}

\begin{abstract}
Esta é uma proposta de pesquisa na área de Matemática Aplicada. O principal objetivo do projeto é resolver, de forma eficiente, Equações Diferenciais Parciais (EDPs), visando a simulação computacional de problemas da área de Dinâmica de Fluidos. Durante o desenvolvimento do projeto será dada ênfase ao desenvolvimento de técnicas computacionais e ao estudo teórico dos métodos numéricos envolvidos na solução destes problemas, tais como a solução numérica de sistemas lineares, métodos de discretização de domínios, geração de malhas adaptativas, métodos conservativos para a aproximação de EDPs, aproximação de dados tabelados, estruturas de dados eficientes e análise dos resultados.
\end{abstract}


\section{Introdução}\label{ss.introducao}

(...) Devido a característica interdisciplinar dos problemas de aplicação envolvendo escoamentos, cada vez mais o tripé composto por teoria, experimento e simulação computacional, se fortalece.  

O presente projeto tem como principal interesse o desenvolvimento e a análise de métodos numéricos e estruturas de dados que visam a simulação computacional de problemas da área de Dinâmica de Fluidos.

\subsection{Objetivos}

O principal objetivo do presente projeto é resolver computacionalmente EDPs. Entre os objetivos específicos destacam-se: desenvolver e implementar métodos numéricos e estruturas de dados eficientes. Para alcançar tais objetivos destacamos a geração de malhas adaptativas dinâmicas, o uso de uma estrutura de dados {\em Tabela de Dispersão} para armazenar e gerenciar os elementos da malha dinâmica, o estudo de diferentes técnicas para a solução dos sistemas lineares, a aproximação de dados tabelados e a implementação de métodos conservativos para aproximar EDPs. Durante a análise dos resultados, vamos utilizar técnicas estatísticas e verificar numericamente a ordem de convergência dos métodos estudados.

\subsection{Relevância da proposta de trabalho}

O presente projeto desempenha um papel interdisciplinar estreitando relações entre os pesquisadores participantes. Além disso, contribuirá na formação de recursos humanos em diferentes níveis (graduação, mestrado e doutorado) nas áreas de Matemática Aplicada, Ciência da Computação e Computação Científica. As metodologias e técnicas que serão apresentadas neste projeto devem contribuir para o progresso do estado da arte e para o tratamento de outros problemas de aplicação das áreas acima citadas.  

As próximas seções estão organizadas da seguinte forma. A Seção~\ref{ss.problema} apresenta uma formulação do problema de interesse. A Seção~\ref{ss.metodologia} apresenta uma proposta de metodologia numérica para a solução dos problemas descritos e cita alguns desafios a serem superados. A Seção~\ref{ss.conclusao} descreve os resultados esperados durante a execução do projeto proposto e um cronograma com as atividades previstas.

\section{Enunciado do problema}\label{ss.problema}

(...)

\subsection{Refinamento Adaptativo de Malhas}

A discretização do domínio computacional baseada na técnica AMR ({\it Adaptive Mesh Refinement}) foi proposta por Berger e Colella \cite{BER91,BER84} e trata problemas dinâmicos (que evoluem no tempo), com refinamento adaptativo em regiões de interesse. Com o refinamento localizado temos menos pontos na discretização e assim, menor custo computacional. O refinamento da malha em regiões de interesse se adapta com base em critérios preestabelecidos. A malha refinada em regiões de interesse é construída a partir de uma sequência de malhas aninhadas hierarquicamente. Inicialmente, vamos considerar domínios computacionais bidimensionais. Posteriormente vamos generalizar para domínios tridimensionais. A Figura~\ref{F1-mesh} apresenta uma sequência de construção de uma malha refinada com dois níveis de refinamento e razão de refinamento igual a dois. Um nível de refinamento $l$ é composto por um conjunto de células que possuem as mesmas dimensões, $\Delta x^l$ e $\Delta y^l$. Na Figura~\ref{F1-mesh} temos $\Delta x^l = \Delta y^l$. A razão de refinamento é dada por $\Delta x^{l}/\Delta x^{l+1} = 2$ sendo $l$ um número inteiro não negativo. 
\begin{figure}[!h]
\begin{center}
\subfigure{\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.6cm,y=0.6cm]
\draw [line width=1.2pt](-3,1)--(-3,5);
\draw [line width=1.2pt](-3,5)--(3,5);
\draw [line width=1.2pt](3,1)--(3,5);
\draw [line width=1.2pt](-3,1)--(3,1);
\draw (-3,2)--(3,2);
\draw (-3,3)--(3,3);
\draw (-3,4)--(3,4);
\draw (-2,1)--(-2,5);
\draw (-1,1)--(-1,5);
\draw (0,1)--(0,5);
\draw (1,1)--(1,5);
\draw (2,1)--(2,5);
\draw (-0.4,5.5) node {{\scriptsize Nível $l=0$, $\Delta x^0$}};
  \end{tikzpicture}}\hspace{0.5pc}
\subfigure{\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.6cm,y=0.6cm]
\draw [line width=1.2pt](-3,1)--(-3,5);
\draw [line width=1.2pt](-3,5)--(3,5);
\draw [line width=1.2pt](3,1)--(3,5);
\draw [line width=1.2pt](-3,1)--(3,1);
\draw (-3,2)--(3,2);
\draw (-3,3)--(3,3);
\draw (-3,4)--(3,4);
\draw (-2,1)--(-2,5);
\draw (-1,1)--(-1,5);
\draw (0,1)--(0,5);
\draw (1,1)--(1,5);
\draw (2,1)--(2,5);
\draw [line width=1.2pt](-3,3)--(-1,3);
\draw [line width=1.2pt](-1,5)--(-1,3);
\draw (-2.5,3)--(-2.5,5);
\draw (-1.5,3)--(-1.5,5);
\draw (-3,4.5)--(-1,4.5);
\draw (-3,3.5)--(-1,3.5);
\draw [line width=1.2pt](1,5)--(1,4);
\draw [line width=1.2pt](1,4)--(0,4);
\draw [line width=1.2pt](0,4)--(0,2);
\draw [line width=1.2pt](0,2)--(3,2);
\draw (0.5,4)--(0.5,2);
\draw (1.5,5)--(1.5,2);
\draw (2.5,5)--(2.5,2);
\draw (0,2.5)--(3,2.5);
\draw (0,3.5)--(3,3.5);
\draw (1,4.5)--(3,4.5);
\draw (0,5.5) node {{\scriptsize Nível $l=1$}};
\draw (-1.5,5.3) node {{\scriptsize $\swarrow$}};
\draw (1.5,5.3) node {{\scriptsize $\searrow$}};
\end{tikzpicture}}\hspace{0.5pc}
\subfigure{\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.6cm,y=0.6cm]
\draw [line width=1.2pt](-3,1)--(-3,5);
\draw [line width=1.2pt](-3,5)--(3,5);
\draw [line width=1.2pt](3,1)--(3,5);
\draw [line width=1.2pt](-3,1)--(3,1);
\draw (-3,2)--(3,2);
\draw (-3,3)--(3,3);
\draw (-3,4)--(3,4);
\draw (-2,1)--(-2,5);
\draw (-1,1)--(-1,5);
\draw (0,1)--(0,5);
\draw (1,1)--(1,5);
\draw (2,1)--(2,5);
\draw [line width=1.2pt](-3,3)--(-1,3);
\draw [line width=1.2pt](-1,5)--(-1,3);
\draw (-2.5,3)--(-2.5,5);
\draw (-1.5,3)--(-1.5,5);
\draw (-3,4.5)--(-1,4.5);
\draw (-3,3.5)--(-1,3.5);
\draw [line width=1.2pt](1,5)--(1,4);
\draw [line width=1.2pt](1,4)--(0,4);
\draw [line width=1.2pt](0,4)--(0,2);
\draw [line width=1.2pt](0,2)--(3,2);
\draw (0.5,4)--(0.5,2);
\draw (1.5,5)--(1.5,2);
\draw (2.5,5)--(2.5,2);
\draw (0,2.5)--(3,2.5);
\draw (0,3.5)--(3,3.5);
\draw (1,4.5)--(3,4.5);
\draw [line width=1.2pt](-3,3.5)--(-2,3.5);
\draw [line width=1.2pt](-2,3.5)--(-2,5);
\draw (-3,4.75)--(-2,4.75);
\draw (-3,4.25)--(-2,4.25);
\draw (-3,3.75)--(-2,3.75);
\draw (-2.75,3.5)--(-2.75,5);
\draw (-2.25,3.5)--(-2.25,5);
\draw [line width=1.2pt](1.5,4.5)--(2.5,4.5);
\draw [line width=1.2pt](2.5,4.5)--(2.5,3);
\draw [line width=1.2pt](2.5,3)--(1.5,3);
\draw [line width=1.2pt](1.5,3)--(1.5,2.5);
\draw [line width=1.2pt](1.5,2.5)--(0.5,2.5);
\draw [line width=1.2pt](0.5,2.5)--(0.5,3.5);
\draw [line width=1.2pt](0.5,3.5)--(1.5,3.5);
\draw [line width=1.2pt](1.5,3.5)--(1.5,4.5);
\draw (0.75,2.5)--(0.75,3.5);
\draw (1.25,2.5)--(1.25,3.5);
\draw (1.75,3)--(1.75,4.5);
\draw (2.25,3)--(2.25,4.5);
\draw (1.5,4.25)--(2.5,4.25);
\draw (1.5,3.75)--(2.5,3.75);
\draw (0.5,3.25)--(2.5,3.25);
\draw (0.5,2.75)--(1.5,2.75);
\draw (-0.5,5.5) node {{\scriptsize Nível $l=2$}};
\draw (-2,5.3) node {{\scriptsize $\swarrow$}};
\draw (1.1,4.9) node {$\searrow$};
\end{tikzpicture}}
\end{center}
\vspace{-2pc}
\caption{Uma sequência de malhas aninhadas com dois níveis.}
\label{F1-mesh}
\end{figure}

Inicialmente, no processo de construção, o nível $l=0$ cobre todo o domínio. Caso alguma região necessite de refinamento, as células que a compõem são substituídas por outras, de um nível mais fino. Na Figura~\ref{F1-mesh}, uma célula de um nível $l$ que está em uma região que necessita de refinamento é substituída por quatro células do nível $l+1$. Assim o processo continua, dependendo da  necessidade e da quantidade de níveis de refinamento.


\section{Metodologia numérica}\label{ss.metodologia}

\subsection{Geração de malhas}

A nossa proposta de malha com refinamento adaptativo visa armazenar apenas as informações de células computacionais visíveis. Simulações numéricas com malhas que armazenavam células fantasmas demostraram um alto custo computacional, principalmente quando uma malha gerada era composta por muitos blocos com refinamento \cite{CAL12}.  As tabelas de dispersão armazenarão apenas as células visíveis. Essa estrutura de dados  é uma tabela que armazena em cada posição zero ou mais células. Cada célula possui uma chave que é dada pelo seu nível e pelas coordenadas de um de seus vértices. Dessa forma, toda chave é única, ou seja, não existem duas células diferentes com chaves iguais. A chave de uma célula é usada para obter um índice da tabela onde a correspondente célula estará armazenada. Para isso, é utilizada uma {\em função de dispersão}, que recebe a chave de uma célula $c$ e devolve um índice da tabela para $c$. A função de dispersão pode não garantir a injetividade. Assim,  a função pode devolver um mesmo índice na tabela para duas chaves de células diferentes. Neste caso, precisamos de um mecanismo para tratar as colisões \cite{GRI99,MUL12,SZW12}. Escolhemos tratar as colisões com listas. Isso significa que duas células distintas podem ser armazenadas em uma lista que está associada a um único índice da tabela. Temos observado que a função de dispersão via método de Fibonacci apresenta um bom comportamento \cite{KNU97}. Há resultados teóricos que garantem que a tabela de dispersão alcança tempo esperado constante para as operações de inserir, remover e buscar células. Para isso, temos que manter a quantidade de índices da tabela ligeiramente maior que o número total de células que queremos armazenar.

\textcolor{red}{Hipergrafos para a localização de vizinhas}


\subsection{Discretização espacial}

Para a discretização espacial utilizaremos o método dos Volumes Finitos. Dessa forma, garantimos as propriedades de conservação nas equações que descrevem o modelo (\ref{s1.eq1})--(\ref{s1.eq4}). A posição das variáveis segue o modelo MAC ({\it marker and cell}: variáveis escalares no centro e as componentes de campos vetoriais nas arestas), veja a Figura~\ref{F4-mesh}(a). Em malhas com refinamento, as células de um nível $l$ podem ser vizinhas de células de um nível diferente. A Figura \ref{F4-mesh} apresenta parte de um domínio computacional com uma interface entre dois níveis de refinamento. Vamos considerar o domínio computacional $\Omega = [a,b]\times[c,d]$ e $\Omega_{ij}^l$ uma célula computacional de um nível $l$ centrada em ${\bf x}^l_{ij}=(a+(i+0.5)\Delta x^l,c+(j+0.5)\Delta y^l)$, com $h_l=\Delta x^l=\Delta y^l$.
\begin{figure}[!h]
\begin{center}
\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.8cm,y=0.8cm]
\draw (-3,1)-- (-3,7);
\draw (-3,7)-- (3,7);
\draw (3,7)-- (3,1);
\draw (-3,5)--(3,5);
\draw (-1,1)-- (-1,7);
\draw (-3,1)-- (3,1);
\draw (-3,3)-- (3,3);
\draw (2,1)-- (2,7);
\draw (1,4)-- (3,4);
\draw (1,2)-- (3,2);
\draw (1,6)--(3,6);
\draw (1,7)-- (1,1);
\begin{scriptsize}
\fill (0,4) circle (2.0pt);
\fill (0,2) circle (2.0pt);
\fill (0,6) circle (2.0pt);
\fill (-2,2) circle (2.0pt);
\fill (-2,4) circle (2.0pt);
\fill (-2,6) circle (2.0pt);
\draw [line width=2pt] (-2.9,6) -> (-3.1,6);
\draw [line width=2pt] (-2.9,4) -> (-3.1,4);
\draw [line width=2pt] (-2.9,2) -> (-3.1,2);
\draw [line width=2pt] (-0.9,6) -> (-1.1,6);
\draw [line width=2pt] (-0.9,4) -> (-1.1,4);
\draw [line width=2pt] (-0.9,2) -> (-1.1,2);
\draw [line width=2pt] (-2,6.9) -> (-2,7.1);
\draw [line width=2pt] (-2,4.9) -> (-2,5.1);
\draw [line width=2pt] (-2,2.9) -> (-2,3.1);
\draw [line width=2pt] (-2,0.9) -> (-2,1.1);
\draw [line width=2pt] (0,6.9) -> (0,7.1);
\draw [line width=2pt] (0,4.9) -> (0,5.1);
\draw [line width=2pt] (0,2.9) -> (0,3.1);
\draw [line width=2pt] (0,0.9) -> (0,1.1);
\fill (1.5,5.5) circle (1.0pt);
\fill (1.5,6.5) circle (1.0pt);
\fill (1.5,3.5) circle (1.0pt);
\fill (1.5,4.5) circle (1.0pt);
\fill (2.5,5.5) circle (1.0pt);
\fill (2.5,6.5) circle (1.0pt);
\fill (2.5,4.5) circle (1.0pt);
\fill (2.5,3.5) circle (1.0pt);
\fill (1.5,2.5) circle (1.0pt);
\fill (2.5,2.5) circle (1.0pt);
\fill (1.5,1.5) circle (1.0pt);
\fill (2.5,1.5) circle (1.0pt);
\draw (0.9,5.5) -> (1.1,5.5);
\draw (0.9,6.5) -> (1.1,6.5);
\draw (0.9,4.5) -> (1.1,4.5);
\draw (0.9,3.5) -> (1.1,3.5);
\draw (0.9,2.5) -> (1.1,2.5);
\draw (0.9,1.5) -> (1.1,1.5);
\draw (1.9,6.5) -> (2.1,6.5);
\draw (1.9,5.5) -> (2.1,5.5);
\draw (1.9,4.5) -> (2.1,4.5);
\draw (1.9,3.5) -> (2.1,3.5);
\draw (1.9,2.5) -> (2.1,2.5);
\draw (1.9,1.5) -> (2.1,1.5);
\draw (2.9,5.5) -> (3.1,5.5);
\draw (2.9,6.5) -> (3.1,6.5);
\draw (2.9,4.5) -> (3.1,4.5);
\draw (2.9,3.5) -> (3.1,3.5);
\draw (2.9,2.5) -> (3.1,2.5);
\draw (2.9,1.5) -> (3.1,1.5);
\draw (1.5,5.9) -> (1.5,6.1);
\draw (1.5,6.9) -> (1.5,7.1);
\draw (1.5,4.9) -> (1.5,5.1);
\draw (1.5,3.9) -> (1.5,4.1);
\draw (1.5,2.9) -> (1.5,3.1);
\draw (1.5,1.9) -> (1.5,2.1);
\draw (1.5,0.9) -> (1.5,1.1);
\draw (2.5,6.9) -> (2.5,7.1);
\draw (2.5,5.9) -> (2.5,6.1);
\draw (2.5,4.9) -> (2.5,5.1);
\draw (2.5,3.9) -> (2.5,4.1);
\draw (2.5,2.9) -> (2.5,3.1);
\draw (2.5,1.9) -> (2.5,2.1);
\draw (2.5,0.9) -> (2.5,1.1);
\end{scriptsize}
\draw (0,0.5) node {(a)};
\end{tikzpicture}%}
\hspace{1.5pc}
\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.8cm,y=0.8cm]
  \draw (-3,7)--(3,7);
\draw (-3,1)-- (-3,7);
\draw (-3,5)-- (3,5);
\draw (3,7)-- (3,1);
\draw (-1,1)-- (-1,7);
\draw (-3,1)-- (3,1);
\draw (-3,3)-- (3,3);
\draw (2,1)-- (2,7);
\draw (1,4)-- (3,4);
\draw (1,2)-- (3,2);
\draw (1,6)--(3,6);
\draw (1,7)-- (1,1);
\draw [dotted] (0,1)-- (0,7);
\draw [dotted] (0,4)-- (1,4);
\draw [dotted] (0,6)--(1,6);
\draw [dotted] (0,2)-- (1,2);
\begin{scriptsize}
\fill (0,4) circle (2.0pt);
\fill (0,2) circle (2.0pt);
\fill (0,6) circle (2.0pt);
\fill (-2,2) circle (2.0pt);
\fill (-2,6) circle (2.0pt);
\fill (1.5,5.5) circle (1.0pt);
\fill (1.5,6.5) circle (1.0pt);
\fill (1.5,3.5) circle (1.0pt);
\fill (1.5,4.5) circle (1.0pt);
\fill (2.5,4.5) circle (1.0pt);
\fill (2.5,5.5) circle (1.0pt);
\fill (2.5,6.5) circle (1.0pt);
\fill (2.5,3.5) circle (1.0pt);
\fill (1.5,2.5) circle (1.0pt);
\fill (2.5,2.5) circle (1.0pt);
\fill (1.5,1.5) circle (1.0pt);
\fill (2.5,1.5) circle (1.0pt);
\draw (0.5,5.5) circle (1.0pt);
\draw (0.5,6.5) circle (1.0pt);
\draw (0.5,1.5) circle (1pt);
\draw (0.5,2.5) circle (1pt);
\draw (0.5,3.5) circle (1pt);
\draw (0.5,4.5) circle (1pt);
\fill (-2,4) circle (2.0pt);
\draw (2,2) circle (2pt);
\draw (2,4) circle (2pt);
\draw (2,6) circle (2.0pt);
\end{scriptsize}
\draw (0,0.5) node {(b)};
\end{tikzpicture}%}
\hspace{1.5pc}
\begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.8cm,y=0.8cm]
  \draw (-3,7)--(3,7);
\draw (-3,1)-- (-3,7);
\draw (-3,5)-- (3,5);
\draw (3,7)-- (3,1);
\draw (-1,1)-- (-1,7);
\draw (-3,1)-- (3,1);
\draw (-3,3)-- (3,3);
\draw (2,1)-- (2,7);
\draw (1,4)-- (3,4);
\draw (1,6)--(3,6);
\draw (1,2)-- (3,2);
\draw (1,7)-- (1,1);
\fill [color=gray!15] (-1,3)--(-1,5)--(1,5)--(1,3);
\draw (-1.2,2.8) node {{\scriptsize A}};
\draw (-1.2,5.2) node {{\scriptsize D}};
\draw (1.2,2.8) node {{\scriptsize B}};
\draw (1.2,5.2) node {{\scriptsize C}};
\draw (0.6,3.5) node {{\scriptsize $E_1$}};
\draw (0.6,4) node {{\scriptsize $E_2$}};
\draw (0.6,4.5) node {{\scriptsize $E_3$}};
\draw [line width=1pt] (-1,3)--(-1,5);
\draw [line width=1pt] (-1,3)--(1,3);
\draw [line width=1pt] (-1,5)--(1,5);
\draw [line width=1pt] ((1,3)--(1,5);
\begin{scriptsize}
  \fill (0,4) circle (2.0pt);
  \draw (0,3.6) node {{\scriptsize $(i,j)$}};
  \fill (0,2) circle (2.0pt);
  \draw (0,1.6) node {{\scriptsize $(i,j-1)$}};
  \fill (0,6) circle (2.0pt);
  \draw (0,5.6) node {{\scriptsize $(i,j+1)$}};
  \fill (1.5,3.5) circle (1.0pt);
  \draw (1.5,3.2) node {{\scriptsize $P_1$}};
  \fill (1.5,4.5) circle (1.0pt);
  \draw (1.5,4.2) node {{\scriptsize $P_4$}};
  \fill (2.5,4.5) circle (1.0pt);
  \draw (2.5,4.2) node {{\scriptsize $P_3$}};
  \fill (2.5,3.5) circle (1.0pt);
  \draw (2.5,3.2) node {{\scriptsize $P_2$}};
\draw (2,4) circle (2pt);
\draw (2,3.7) node {{\scriptsize $(i+1,j)$}};
\fill (-2,4) circle (2pt);
\draw (-2,3.6) node {{\scriptsize $(i-1,j)$}};
\draw [line width=2pt] (-1.1,4) -> (-0.9,4);
\draw (0.9,4.5) -> (1.1,4.5);
\draw [line width=2pt] (0.9,4) -> (1.1,4);
\draw [line width=2pt] (0,4.9) -> (0,5.1);
\draw [line width=2pt] (0,2.9) -> (0,3.1);
\draw (0.9,3.5) -> (1.1,3.5);
\end{scriptsize}
\draw (0,0.5) node {(c)};
\end{tikzpicture}
\end{center}
\vspace{-2pc}
 \caption{(a) Localização das variáveis: $\bullet$ escalares e {\bf -} campo vetorial; (b) Células computacionais: $\bullet$ representa uma célula computacional na posição ${\bf x}_{ij}$ e $\circ$, células auxiliares ({\it fantasmas}); e (c) Discretização com correção de fluxos.}
\label{F4-mesh}
\end{figure}

O método dos Volumes Finitos resulta em um conjunto de equações discretas obtido por meio do balanço de fluxos sobre as células computacionais $\Omega^l_{ij}$. Isso significa que na discretização espacial vamos utilizar informações de células vizinhas.  Como um exemplo, vamos considerar a equação de Laplace,  
\begin{equation}\label{s2.eq5}
-\nabla\cdot(\lambda\nabla \phi) = -\dfrac{\partial}{\partial x}\left(\lambda\dfrac{\partial\phi}{\partial x}\right) - \dfrac{\partial}{\partial y}\left(\lambda\dfrac{\partial\phi}{\partial y}\right) = f,
\end{equation}
com alguma condição para as fronteiras, sendo $\lambda$ o coeficiente difusivo e $f$, funções conhecidas. Integrando (\ref{s2.eq5}) sobre cada célula $\Omega^l_{ij}$, usando o teorema de Gauss no lado esquerdo e aproximando o lado direito da equação (\ref{s2.eq5}), obtemos
\begin{equation}\label{s2.eq6}
-\int_{\Omega_{ij}^l}\nabla\cdot(\lambda\nabla \phi)d\Omega  = -\sum_{k=1}^4\int_{\partial\Omega_{ij}^l}\lambda\nabla\phi\cdot{\bf n}dS_k \simeq f_{ij}h_l^2,
\end{equation}
sendo $f_{ij}$ o valor da função $f$ avaliada em ${\bf x}^l_{ij}$ e ${\bf n}$ o vetor unitário normal às arestas de $\Omega_{ij}^l$. As componentes do fluxo ${\bf F} = \lambda\nabla \phi$ devem ser avaliadas em cada uma das arestas. Por exemplo, no volume em destaque na Figura~\ref{F4-mesh}(c), a aproximação do fluxo na aresta $AB$ é dada por
\begin{equation}\label{s2.eq7}
-\int_A^B\lambda\dfrac{\partial\phi}{\partial y}dx \simeq h_l\lambda_{i,j-\frac{1}{2}}\left(\dfrac{\phi_{ij}-\phi_{i,j-1}}{h_l}\right)=\lambda_{i,j-\frac{1}{2}}(\phi_{ij}-\phi_{i,j-1}),
\end{equation}
sendo $\lambda_{i,j-\frac{1}{2}}$ a função $\lambda$ avaliada na posição ${\bf x}^l_{i,j-\frac{1}{2}}$. Assim, se uma célula possui todas as vizinhas no mesmo nível de refinamento, a equação discreta é dada por,
\begin{equation}\label{s2.eq8}
a_w\phi_{i-1,j}+a_e\phi_{i+1,j}+a_c\phi_{ij}+a_s\phi_{i,j-1}+a_n\phi_{i,j+1} = f_{ij},
\end{equation}
sendo $a_s=-(1/h_l^2)\lambda_{i,j-\frac{1}{2}}$, $a_n=-(1/h_l^2)\lambda_{i,j+\frac{1}{2}}$, $a_w=-(1/h_l^2)\lambda_{i-\frac{1}{2},j}$, $a_e=-(1/h_l^2)\lambda_{i+\frac{1}{2},j}$ e $a_c=-(a_n+a_s+a_e+a_w)$. 

Na malha adaptativa, conforme \cite{TRO01}, essa aproximação será feita por meio de interpolações, envolvendo as {\em células fantasmas} \cite{LEV02,TRO01,VER07}, veja Figura~\ref{F4-mesh}(b). Por exemplo, no volume em destaque na Figura~\ref{F4-mesh}(c), a aproximação do fluxo na aresta $BC$ é dada por 
\begin{equation}\label{s2.eq9}
-\int_B^C\lambda\dfrac{\partial\phi}{\partial x}dy \simeq h_l\lambda_{i+\frac{1}{2},j}\left(\dfrac{\phi_{i+1,j}-\phi_{ij}}{h_l}\right)=\lambda_{i+\frac{1}{2},j}(\phi_{i+1,j}-\phi_{ij}).
\end{equation}
Note que $\phi_{i+1,j}$ está localizado em uma célula fantasma. 

\textcolor{red}{Aproximação de dados tabelados}

\subsection{Sistemas lineares}

\textcolor{red}{Matrizes e Grafos de adjacência}

Vamos analisar a construção das matrizes associadas a discretização do problema em uma malha adaptativa. As matrizes possuirão uma estrutura esparsa que dependerá da maneira como as células são enumeradas \cite{SAA03}. Vamos seguir o processo de construção  da matriz de coeficientes em uma malha adaptativa apresentado em~\cite{ALV13}, explorando outras formas de enumerar as células da malha adaptativa e reordenar uma enumeração. Vamos analisar duas estratégias para resolver os sistemas lineares. Uma delas, aplicando métodos iterativos, como o {\it Multigrid} algébrico \cite{TRO01}. A segunda estratégia é utilizar métodos de decomposição de domínios que se baseiam na técnica de divisão e conquista \cite{SAA03}. Este último é um passo natural para a paralelização da metodologia.

\section{Resultados esperados}\label{ss.conclusao}

O presente projeto interdisciplinar possui duração de três anos e conta com a colaboração de quatro pesquisadores: os professores, Dr. Álvaro Junio Pereira Franco (INE) e Dra. Priscila Cradoso Calegari (DEC) da Universidade Federal de Santa Catarina e os professores, Dra. Catalina Maria Rua Alvarez e Dr. John Hermes Castillo Gomez da Universidad de Nari\~no, Pasto - Colômbia.  

Os principais resultados esperados são:
\begin{enumerate}
  \vspace{-1pc}
\item [(a)] a apresentação de uma ferramenta computacional, devidamente validada, que resolva o problema apresentado;
  \vspace{-0.5pc}
  \item [(b)] a obtenção de resultados nos tópicos propostos que contribuam com o progresso do estado da arte; 
  \vspace{-0.5pc}
\item [(c)] a submissão desses trabalhos em periódicos e congressos das áreas de Análise Numérica, Dinâmica de Fluidos Computacional, Computação Científica e Matemática Aplicada; e 
  \vspace{-0.5pc}
  \item [(d)] o fortalecimento da colaboração entre os pesquisadores envolvidos e a formação de recursos humanos.
  \end{enumerate}

Durante todo o período pretendemos sempre manter a pesquisa atualizada com a literatura. Além disso, serão submetidos trabalhos e artigos para congressos e revistas das áreas de Análise Numérica, Computação Científica, Matemática Aplicada e Dinâmica de Fluidos Computacional. Os resultados têm alto potencial de aplicação na Engenharia.

\begin{footnotesize}
\bibliographystyle{acm}
\bibliography{bibliografia}
\end{footnotesize}


\end{document}
